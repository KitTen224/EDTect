import { JapanTimeline, TimelineActivity, JapanRegion, RegionWithDays } from '@/types/travel'; // Import JapanRegion v√† RegionWithDays

interface AdjustRequest {
  regions: RegionWithDays[]; // ƒê·∫£m b·∫£o ki·ªÉu d·ªØ li·ªáu ch√≠nh x√°c
  totalDuration: number;
  travelStyles?: any[];
  interests?: any[];
  season?: any;
  overrideRequest?: string;
}

// G·ªçi Gemini v√† tr·∫£ v·ªÅ JapanTimeline kh·ªõp frontend
export async function regenerateTimelineWithOverride(
  requestData: AdjustRequest
): Promise<JapanTimeline> {
  const response = await fetch('http://localhost:3000/api/ai/adjust-itinerary', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestData)
  });

  const result = await response.json();
  console.log("üëâ Raw response from Next.js API:", result); // Log raw response

  if (!response.ok) { // Ki·ªÉm tra tr·∫°ng th√°i HTTP response
    throw new Error(result.error || 'Failed to fetch itinerary from AI API');
  }

  if (!result.itinerary) {
    throw new Error('No itinerary returned in API response.');
  }

  let parsed;
  try {
    parsed = JSON.parse(result.itinerary); // Parse itinerary t·ª´ chu·ªói JSON
    console.log("üëâ Parsed itinerary on frontend:", JSON.stringify(parsed, null, 2)); // Log JSON ƒë√£ parse
  } catch (err) {
    console.error("‚ùå Failed to parse AI itinerary JSON from API response:", err);
    throw new Error('Failed to parse AI itinerary JSON received from API. Please check Gemini output format.');
  }

  // üí° Th√™m ki·ªÉm tra c·∫•u tr√∫c c∆° b·∫£n c·ªßa output parsed
  if (!parsed || !Array.isArray(parsed.days)) {
    console.error("‚ùå Parsed data does not contain a 'days' array:", parsed);
    throw new Error("Invalid itinerary structure received from API. Missing 'days' array.");
  }


  const days = parsed.days.map((day: any, index: number) => {
    // üí° S·ª≠a: T√¨m ki·∫øm JapanRegion ƒë·∫ßy ƒë·ªß t·ª´ requestData.regions
    // S·ª≠ d·ª•ng toLowerCase() ƒë·ªÉ so s√°nh kh√¥ng ph√¢n bi·ªát ch·ªØ hoa/th∆∞·ªùng
    const foundRegionData = requestData.regions.find(
      (r: RegionWithDays) => r.region.name.toLowerCase() === (day.region?.toLowerCase() || '')
    );

    const timelineRegion: JapanRegion = foundRegionData?.region || {
      id: day.region ? day.region.toLowerCase().replace(/\s/g, '-') : `unknown-region-${index + 1}`, // T·∫°o ID gi·∫£ ƒë·ªãnh
      name: day.region || `Unknown Region Day ${index + 1}`,
      nameJapanese: '', // C√≥ th·ªÉ c·∫ßn logic ƒë·ªÉ l·∫•y t√™n ti·∫øng Nh·∫≠t
      description: 'Region generated by AI',
      icon: '‚ùì',
    };
    console.log(`üëâ Mapped Timeline Region for Day ${day.dayNumber || index + 1}:`, timelineRegion);


    const normalizedActivities: TimelineActivity[] = (day.activities || []).map((a: any, i: number): TimelineActivity => ({
      id: a.id || `${day.dayNumber || index + 1}-activity-${i + 1}`, // ƒê·∫£m b·∫£o lu√¥n c√≥ ID
      name: a.title || a.name || `Activity ${i + 1}`,
      description: a.description || '',
      startTime: normalizeTime(a.startTime || a.time || '09:00'), // ∆Øu ti√™n startTime, fallback time, r·ªìi default
      duration: Number(a.duration) || 60,
      // üí° S·ª≠a: X·ª≠ l√Ω cost m·∫°nh m·∫Ω h∆°n ƒë·ªÉ tr√°nh NaN
      estimatedCost: parseCost(a.cost),
      type: a.type || 'experience',
      icon: a.icon && typeof a.icon === 'string' && a.icon.length > 0 ? a.icon : 'üìç', // ƒê·∫£m b·∫£o icon l√† chu·ªói v√† kh√¥ng r·ªóng
      location: a.location || 'Unknown'
    }));

    // üí° Ki·ªÉm tra v√† log c√°c ho·∫°t ƒë·ªông ƒë√£ normalize
    console.log(`üëâ Normalized Activities for Day ${day.dayNumber || index + 1}:`, normalizedActivities);

    return {
      dayNumber: day.dayNumber || index + 1,
      region: timelineRegion, // S·ª≠ d·ª•ng object JapanRegion ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a
      activities: normalizedActivities,
      totalCost: normalizedActivities.reduce(
        (sum, act) => sum + (act.estimatedCost ?? 0), 0
      )
    };
  });

  return {
    days,
    totalDuration: requestData.totalDuration,
    regions: requestData.regions, // Gi·ªØ nguy√™n regions ban ƒë·∫ßu
    travelStyles: requestData.travelStyles || [],
    season: requestData.season || null
  };
}

// üïê Helper: chu·∫©n h√≥a time th√†nh HH:MM
function normalizeTime(time: string | number): string {
  if (typeof time === 'number') {
      time = String(time); // Chuy·ªÉn s·ªë th√†nh chu·ªói n·∫øu Gemini tr·∫£ v·ªÅ s·ªë
  }
  if (!time || typeof time !== 'string' || !time.includes(':')) {
    console.warn(`‚ö†Ô∏è Invalid time format received: "${time}". Defaulting to "09:00".`);
    return '09:00';
  }
  const [h, m] = time.split(':').map((v) => v.padStart(2, '0'));
  return `${h}:${m}`;
}

// üí∞ Helper: X·ª≠ l√Ω chi ph√≠ ƒë·ªÉ tr√°nh NaN
function parseCost(cost: any): number {
  if (typeof cost === 'number') {
    return cost; // N·∫øu ƒë√£ l√† s·ªë th√¨ tr·∫£ v·ªÅ lu√¥n
  }
  if (typeof cost === 'string') {
    // Lo·∫°i b·ªè t·∫•t c·∫£ k√Ω t·ª± kh√¥ng ph·∫£i s·ªë ho·∫∑c d·∫•u ch·∫•m
    const cleanedCost = cost.replace(/[^0-9.]/g, '');
    const parsed = parseFloat(cleanedCost);
    if (!isNaN(parsed)) {
      return parsed;
    }
  }
  console.warn(`‚ö†Ô∏è Invalid cost format received: "${cost}". Defaulting to 0.`);
  return 0; // Tr·∫£ v·ªÅ 0 n·∫øu kh√¥ng th·ªÉ parse th√†nh s·ªë
}